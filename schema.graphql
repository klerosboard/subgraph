# KlerosLiquid entities
enum Period {
  "Evidence can be submitted. This is also when drawing has to take place."
  evidence,
  "Jurors commit a hashed vote. This is skipped for courts without hidden votes."
  commit,
  "Jurors reveal/cast their vote depending on whether the court has hidden votes or not."
  vote, 
  "The dispute can be appealed."
  appeal,
  "Tokens are redistributed and the ruling is executed."
  execution
}

type StakeSet @entity {
  id: ID!
  address: Bytes! # address
  subcourtID: BigInt! # uint256
  stake: BigInt! # uint128
  newTotalStake: BigInt! # uint256
}

type Dispute @entity {
  id: ID!,
  "Arbitrable SC who raised the dispute"
  arbitrable: Bytes!,
  "wallet who raise the dispute"
  creator: Bytes!,
  "Subcourt ID"
  subcourtID: BigInt!,
  "Number of choices wihtin the dispute"
  numberOfChoices: BigInt!,
  "Current Period of the dispute"
  period: Period!
  "Timestamp when the dispute was raised"
  startTime: BigInt!
  "Timestamp of the last period change"
  lastPeriodChange: BigInt!,
  "Rounds in the dispute"
  rounds: [Round!] @derivedFrom(field:"dispute")
  "Is ruled the case?"
  ruled: Boolean!
  "Current choice ruled"
  currentRulling: BigInt,
  "List of jurors (wallets) involved in the dispute"
  jurorsInvolved: [Juror!],
  "Metaevidence of the dispute. Question and options"
  metaevidente: String
}

type Round @entity {
  "identifier, hash tx"
  id: ID!,
  "Dispute asociated to the round"
  dispute: Dispute!,
  "List of votes in the round"
  votes: [Vote!]! @derivedFrom(field: "round")
  "which choice wins in the round?"
  winningChoice: BigInt!,
  "Timestamp of the beggining of the round"
  startTime: BigInt!
}

type Vote @entity {
  "id of the vote: disputeId-voteid"
  id: ID!,
  "Dispute associated for this vote"
  dispute: Dispute!,
  "Round within the dispute where the vote is casted"
  round: Round!,
  "Vote identificator"
  voteID: BigInt!,
  "Address who was selected to vote"
  address: Bytes!,
  "Choice selected"
  choice: BigInt,
  "Boolean to indicate if the vote was casted. If not, the choice 0 indicates pending"
  voted: Boolean!,
  "Salt of the vote"
  salt: BigInt,
  "timestamp of the vote casted"
  timestamp: BigInt,
}

type NewPeriod @entity {
  id: ID!
  disputeId: BigInt!,
  newPeriod: Period!
}

type Draw @entity {
  "drawID: disputeID-voteID"
  id: ID!,
  "address drawn in the vote"
  address: Bytes!,
  "dispute ID"
  disputeId: BigInt!,
  "appeal round"
  roundNumber: BigInt!,
  "vote ID of the vote in this dispute"
  voteId: BigInt!,
  "timestamp when the vote was drawn"
  timestamp: BigInt!
}

type Juror @entity {
  "address, juror (person) maybe has multiple addresses."
  id: ID!,
  subcourtsIDs: [BigInt!],
  totalStaked: BigInt!,
  activeJuror: Boolean,
  disputesAsJuror: [Dispute!],
  numberOfDisputesCreated: BigInt!,
  "This could be derivedFrom the Votes entity, but there should be used the jurors entity instead of bytes"
  votes: [Vote!]
}

type TokenAndETHShift @entity {
  id: ID!,
  disputeId: BigInt!,
  tokenAmount: BigInt!,
  ETHAmount: BigInt!
}

## PolicyUpdate entities
type PolicyUpdate @entity {
  id: ID!
  subcourtID: BigInt! # uint256
  policy: String! # String
  contractAddress: Bytes! # address
  timestamp: BigInt! # uint256
  blockNumber: BigInt! # unit256
}